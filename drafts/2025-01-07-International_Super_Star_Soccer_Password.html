---
title: Reverse engineering the International Super Star Soccer password - Part 1
layout: singlePost
comments: true
---
<p>
    Does looking at this image makes you feel frustrated?
</p>
<p>
    <img src="/assets/img/issd/issdPassword.png" alt="International Super Star Soccer Deluxe huge password" />
</p>

<p>
    This is a screenshot of the game "International Super Star Soccer Deluxe" for the Super Nintendo. 
</p>
<p>
    Released in 1995, it was the successor of the popular "International Super Star Soccer" for the same console.
    It was a very popular game at the time, and even today there are still people releasing moded versions of this game.
</p>
<p>
    But, besides the big number of teams to choose and all the game modes, it was also known for its huge password system.    
    The password entry screen allowed to password up to size 60, had no vowels and mixed lettes, special characters with numbers.
    It was very easy to make a mistake when typing it (very annoying), and specially writing down the wrong passowrd (more than just very annoying).
</p>
<p>
    I, particularly, did not have a snes but I've seen the password screen in other's people houses and I always wondered what was the logic behind it.
    I knew somehow the game state was encoded in the password, but I could not find any information about it.
</p>
<p>
    Recently I saw a meme about the game password system and decided to look into it. 
    I thought obviously someones must have figured it out by now. To my surprise I could not find any 
    information about it except for 
    <a href="https://www.reddit.com/r/snes/comments/87efoe/international_superstar_soccer_deluxe_password/">someone on reddit who started the same 
        quest and dissapeared.</a>
</p>
<p>
    I am on vacations and I have some time to spare, so I decided to look into it myself.
</p>
<p>
    Let's start from the beginning.
</p>
<h1>Finding the right tools</h1>
<p>
    I have no prior knowledge about snes rom hacking. I did know that you can use the emulator to scan the memory and look for 
    values based on how they changed. My theory was that the password was just the game state with a checksum so just looking at the 
    memory would give me a good idea of how it worked, without having to look much into the actual instructions. 
</p>
<p>
    It turns out that there was no way I would figure out how it worked only from looking at the  values on the memory.
</p>
<p>
    With the lucky of the very stupid, I wasn't able to find the value on the memory with a popular emulator, which prompted me to find some emulator that 
    could also debug the instructions being executed. One great emulator that does this is 
    <a href="https://github.com/devinacker/bsnes-plus">bsnes-plus</a>, a fork of bsnes with debbugging tools.
</p>
<p>
    Bsnes plus has no binaries for Linux, but luckly compiling it was a breeze. I did have issues running it, 
    but turns out it <a href="https://github.com/devinacker/bsnes-plus/issues/277">did not run out of the box on ubuntu using wayland</a>. Using xcb 
    solved the issue.
<pre>
    export QT_QPA_PLATFORM=xcb
</pre>
</p>
<p>
    So, back to the passowrd generator.
</p>
<p>
    The way you create cheats in an emulator is by scanning the whole memory and looking for values that 
    increased, decreased or stayed the same.
</p>
<p>
    For example, let's say you have a game where you have some health represented by hearts. You are not sure what value represent this health in memory. 
</p>
<p>
    What you can do is scan the whole memory, then get hit and scan again for values that are lesser than the previous one. 
    You can then scan for values that stay the same as the previous one. Lose health and search again, or even better, gain health and scan for values that increased.
</p>
<p>
    This way you can narrow down the memory address that represents the health. Then you can change this value and see how it affects the game.
</p>
<p>
    This is what the cheat finder looks on bsnes-plus:
</p>
<p>
    <img src="/assets/img/issd/MemoryScan.png" alt="Cheat finder screenshot" />
</p>
<h1>Looking for the right place in memory</h1>
<p>
    With the same strategy we use too look for cheats, we can look for the place in memory where the password is stored.
</p>
<p>
    What we need to do then is open the passowrd screen, scan the whole memory, then change the first character of the password and 
    scan again for values that changed.
</p>
<p>
    Then we scan again a few times for values that did not change. This will eliminate animations, like the rolling balls character placeholders 
    or the rotating cursor.
</p>
<p>
    We can also changed the first character to something else to look for values that changed.
</p>
<p>
    A few scans later I ended up with this:
</p>
<p>
    <img src="/assets/img/issd/2Candidates.png" alt="Two possible places" />
</p>
<p>
    This is very promising. Lets look at them.
</p>
<p>
    First, let`s type a sequential password.
</p>
<p>
    <img src="/assets/img/issd/sequentialPassword.png" alt="A nice sequential password." />
</p>
<p>
    This is 7fe18a:
</p>
<p>
    <img src="/assets/img/issd/PassSpritesOnMemoryAnnotated.png" alt="This is not the right place." />
</p>
<p>
    The higlighted part is where the memory changes when we change the password. There are many interesting things here.
</p>
<p>
    Each entry is 16 bits long. All entries are paired with a 0x20 value. There is a strange gap between the entries.
</p>
<p>
    And finally, if we try to find out which character corresponds to each value we end up with these interesting discontinuities.
</p>
<pre>
    B - 71 20
    C - 72 20
    D - 73 20
    ????????? Space for E
    F - 75 20
    G - 76 20
    H - 77 20
    ????????? Space for I
    J - 79 20
    ...
</pre>
<p>
    From this, we can conclude those values are probably this is pointing to a tile sheet with the char table.
</p>
<p>
    Let's look at the next candidate 7ee2d0. This is what we see:
</p>
<p>
    <img src="/assets/img/issd/sequentialMemory.png" alt="Perfect correspondence between values." />
</p>
<p>
    Perfect. We can assume that if there is any type of calculation going on, it would be easier to use consecutive numbers starting from 0.
    We can hopefullly assume that this is the right place.
</p>
<p>
    Now that we have the memory address, we can use the bsnes plus debugger to see how this is being used. 
    Bsnes allows us to set a breakpoint on any memory address and choose to stop on read, write or execute.
</p>

<p>
    <img src="/assets/img/issd/MemoryReadBreakpoint.png" alt="Breakpoint on read at 7ee2d0." />
</p>
<p>
   We then add this breakpoint and try a new password. Immediately we stop at the breakpoint at 0x86cb3b. Success!
</p>
<p>
    Now, this is only one instruction inside a whole subroutine. We need to look at the whole thing to understand how it works. 
    Here is what we have:
</p>
<p>
    <img src="/assets/img/issd/mainLoop.png" alt="The read password function." />
</p>
<p>
    Well, now would be a good time to look at the snes cpu and the 65C816 assembly. This is a very, very shallow look at what we are dealing with here. 
    For our purposes, we only need to know as we go.
</p>
<p>
The unavoidable concepts here are:
<ul>
    <li>Register A, the accumulator register. Used for any calculation.</li>
    <li>X and Y registers, the index register. Used to dynamically point to different memory adresses.</li>
    <li>Data Bank: Imagine this as an offset to be appended to a memory address. You can set it inside the DB register.</li>
    <li>The flags. Stored in the Processor Status Register (P), each one has one function. We will care only About M, N and C.</li>
    <li>Flag M Memory/Accumulator Width Flag - Switches between 8 bit and 16 bit mode.</li>
    <li>Flag N Indicates whether the result of the last operation was negative</li>
    <li>Flag C Indicates a carry or borrow from the last operation</li>
</ul>
</p>
<p>
    Bsnes plus also have tracing capabilities, so we can follow the logic while also looking at the register values and flags.
</p>
<p>
    This is a trace:
</p>
<pre>
86cb27 jsr $cb13      [86cb13] A:0000 X:0004 Y:0080 S:0192 D:0000 DB:81 .....IZ. V:246 H:191 F:22

86cb27 is the address of the instruction
jsr is the instruction, in this case jump to subroutine
$cb13 is the address of the subroutine
[86cb13] is the actual address cb13 resolves to.
Then we have the registers and flags.
Register A is the accumulator, X and Y are the index registers, S is the stack pointer, D is the direct page register, DB is the data bank register.
The flags are the processor status flags. If they are on we see the flag character, if they are off we see a dot.
Then we have the V sync and H sync counters and finally the frame counter.
</pre>

<p>
    From the code we can observe that:
    <ul>
        <li>A subroutine is called at 86cb27 jsr $cb13, let's call it gameFunctionA. jsr is Jump to subroutine and basically means call a function inside the Data Bank.</li>
        <li>A subroutine is called at 86cb33 jsl $808b4c, let's call it globalFunctionA. jsl is Long Jump to subroutine. Unlike jsr, it can call subroutines anywhere.</li>
        <li>There is a bcc instruction pointing to an address inside this same subroutine. 86cb61 bcc $cb26. This is a loop.</li>
    </ul>
</p>
<p>
We can go through each instruction and see what is happening.
</p>
<pre>
This is gameFunctionA
86cb13 phb                     A:0000 X:0004 Y:0080 S:0190 D:0000 DB:81 .....IZ.
PHB - Push Data Bank Register - this is used to save the current data bank register value on the stack.
86cb14 lda #$0000              A:0000 X:0004 Y:0080 S:018f D:0000 DB:81 .....IZ.
LDA - Load Accumulator - this is used to load a value into the accumulator. #$0000 is the immediate value 0.
In other words, this is setting A to 0.
86cb17 sta $1700      [811700] A:0000 X:0004 Y:0080 S:018f D:0000 DB:81 .....IZ.
STA - Store Accumulator - this is used to store the value in the accumulator into a memory address. In this case, it is storing 0 into 811700.
86cb1a lda #$0039              A:0000 X:0004 Y:0080 S:018f D:0000 DB:81 .....IZ.
Puts 39 into A
86cb1d ldx #$1701              A:0039 X:0004 Y:0080 S:018f D:0000 DB:81 .....I..
Puts 1701 into X
86cb20 txy                     A:0039 X:1701 Y:0080 S:018f D:0000 DB:81 .....I..
TXY - Transfer X to Y
86cb21 iny                     A:0039 X:1701 Y:1701 S:018f D:0000 DB:81 .....I..
INY - Increment Y, see on the next trace line it went from 1701 to 1702.
86cb22 mvn $00, $00            A:0039 X:1701 Y:1702 S:018f D:0000 DB:81 .....I..
MVN - Block Move Negative - this is used to copy a block of memory from one location to another.
The source is the source bank byte concatenated with the contents of the X register.
The destination is the destination bank byte concatenated with the contents of the Y register.
The size is the value in the A register. A is 39, so it is copying 39 bytes from 1701 t0 1702.
...
86cb22 mvn $00, $00            A:0001 X:1739 Y:173a S:018f D:0000 DB:00 .....I..
86cb22 mvn $00, $00            A:0000 X:173a Y:173b S:018f D:0000 DB:00 .....I..
86cb25 plb                     A:ffff X:173b Y:173c S:018f D:0000 DB:00 .....I..
PLB - Pull Data Bank Register - this is used to restore the data bank register value from the stack.
86cb26 rts                     A:ffff X:173b Y:173c S:0190 D:0000 DB:81 N....I..
RTS - Return from Subroutine - this is used to return from a subroutine.
So, this is the end of gameFunctionA. It is apparently moving a block of memory from 1701 to 1702.
Let's call it setup.

Back to the main loop
86cb2a stz $00        [000000] A:ffff X:173b Y:173c S:0192 D:0000 DB:81 N....I..
86cb2c stz $02        [000002] A:ffff X:173b Y:173c S:0192 D:0000 DB:81 N....I..
STZ - Store Zero - this is used to store the value 0 into a memory address.
Or, in other words, initializing some stack variables with 0.

Here we have a loop starting
86cb2e lda $02        [000002] A:ffff X:173b Y:173c S:0192 D:0000 DB:81 N....I..
Copies the value at the stack $02 into A
86cb30 ldy #$0008              A:0000 X:173b Y:173c S:0192 D:0000 DB:81 .....IZ.
Puts 8 into Y
86cb33 jsl $808b4c    [808b4c] A:0000 X:173b Y:0008 S:0192 D:0000 DB:81 .....I..

Jumps to the subroutine at 808b4c
The values on the registers A and Y are important to this subroutine (the why is coming)
808b4c sta $4204      [814204] A:0000 X:173b Y:0008 S:018f D:0000 DB:81 .....I..
Copies the value in A into $4204
This one requires a little bit of research.
One special feature exclusive to the 65c816 snes cpu is native division.
The 65C816 processor in the SNES does not have a dedicated division instruction.
Instead, division is performed by a hardware division unit.
- The CPU writes the dividend, a 16-bit value, to memory addresses $4204 (lower byte) and $4205 (higher byte)
- The CPU writes the divisor, an 8-bit value, to memory address $4206. Writing to this address also initiates the division
The quotient, which is the result of the division, is then read from memory addresses $4214 (lower byte) and $4215 (higher byte)
The remainder can be read from memory addresses $4216 (lower byte) and $4217 (higher byte)
So, A:0000 is the dividend.
808b4f sep #$20                A:0000 X:173b Y:0008 S:018f D:0000 DB:81 .....I..
This one will appear a lot. This is setting the bit on the P register corresponding to the M flag.
When the M flag is set, the accumulator and memory operations are 8-bit
808b51 tya                     A:0000 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
Copies Y to A
808b52 sta $4206      [814206] A:0008 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
Now A is the divisor (with the value that was previously on Y)
808b55 lda #$03                A:0008 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
Put 3 on a
808b57 dec                     A:0003 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
Decrements A
808b58 bne $8b57      [808b57] A:0002 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
Jumps out if A is not zero
808b57 dec                     A:0002 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
808b58 bne $8b57      [808b57] A:0001 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
808b57 dec                     A:0001 X:173b Y:0008 S:018f D:0000 DB:81 ..M..I..
808b58 bne $8b57      [808b57] A:0000 X:173b Y:0008 S:018f D:0000 DB:81 ..M..IZ.
A loop that spends three cpu cycles. I 

808b5a rep #$20                A:0000 X:173b Y:0008 S:018f D:0000 DB:81 ..M..IZ.
808b5c lda $4214      [814214] A:0000 X:173b Y:0008 S:018f D:0000 DB:81 .....IZ.
808b5f ldy $4216      [814216] A:0000 X:173b Y:0008 S:018f D:0000 DB:81 .....IZ.
808b62 rtl                     A:0000 X:173b Y:0000 S:018f D:0000 DB:81 .....IZ.


86cb37 sta $04        [000004] A:0000 X:173b Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb39 ldx $00        [000000] A:0000 X:173b Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb3b lda $7ee2d0,x  [7ee2d0] A:0000 X:0000 Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb3f and #$00ff              A:3a0b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb42 cmp #$0040              A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb45 bcs $cb63      [86cb63] A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 N....I..
86cb47 ror                     A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 N....I..
86cb48 rol                     A:0005 X:0000 Y:0000 S:0192 D:0000 DB:81 .....I.C
86cb49 dey                     A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb4a bpl $cb48      [86cb48] A:000b X:0000 Y:ffff S:0192 D:0000 DB:81 N....I..
86cb4c ldy $04        [000004] A:000b X:0000 Y:ffff S:0192 D:0000 DB:81 N....I..
86cb4e ora $1700,y    [811700] A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb51 sta $1700,y    [811700] A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb54 inc $00        [000000] A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb56 lda $02        [000002] A:000b X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb58 clc                     A:0000 X:0000 Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb59 adc #$0006              A:0000 X:0000 Y:0000 S:0192 D:0000 DB:81 .....IZ.
86cb5c sta $02        [000002] A:0006 X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb5e cmp #$0168              A:0006 X:0000 Y:0000 S:0192 D:0000 DB:81 .....I..
86cb61 bcc $cb2e      [86cb2e] A:0006 X:0000 Y:0000 S:0192 D:0000 DB:81 N....I..
</pre>



The snes cpu and the 65C816 assembly

I expected to be able to disassemble the rom and look at it, but that is, surprisingly not possible. 
Snes has a M flag, when it is set, operations are 8 bits, when it is clear, operations are 16 bits.
Because snes support 8 and 16 bit modes, and it depends on what is set on the flag, it is only possible to actually know the value sizes at runtime.

BSnes plus

Fist step, find the place in memory where the password is stored.
For this, we can use the memory scanner. First we scann repeatadelly for values that dont change.
This eliminates animations, like the rolling balls character placeholders or the rotating cursor.
We then change the first character and look for values that changed. Do it again a couple of times and end up with this:

....

Now we can use the BSnes debugger and look at this memory address. We can then change the password and see how this is affected.


See that only the first byte matters. That is because it maps to the sprite sheet.

Now we can add a read breakpoint:

And we end up with this call (thanks chatgpt for the comments):

Memory adresses
$810048 - 

808ff5  lda #$4300                            ; Load the immediate value $4300 into the accumulator
808ff8  tcd                                    ; Transfer the accumulator to the Direct Page Register (DPR)
808ff9  ldy #$0001                             ; Load the immediate value $0001 into the Y register
808ffb  brk #$a2                               ; Break (interrupt with vector determined by $a2)
808ffc  ldx #$3600                             ; Load the immediate value $3600 into the X register
;;; Loop Starts
808fff  cpx $0048                    [810048]; Compare the X register with the value at address $0048
;;; Loop exit condition
809002  bcs $9041                              ; Branch to $9041 if the Carry flag is set
809004  lda $7e0004,x               [7e0004]; Load the value at address ($7e0004 + X) into the accumulator
809008  sta $2116                    [812116]; Store the accumulator value into the address $2116
80900b  lda $7e0006,x               [7e0006]; Load the value at address ($7e0006 + X) into the accumulator
80900f  sta $02                       [000002]; Store the accumulator value into the address $02
809011  lda $7e0009,x               [7e0009]; Load the value at address ($7e0009 + X) into the accumulator
809015  sta $05                       [000005]; Store the accumulator value into the address $05
809017  lda $7e0002,x               [7e0002]; Load the value at address ($7e0002 + X) into the accumulator
80901b  sta $00                       [000000]; Store the accumulator value into the address $00
80901d  sep #$20                              ; Set processor status bits defined by $20 (e.g., enable 8-bit accumulator and index registers)
80901f  lda $7e0000,x               [7e0000]; Load the value at address ($7e0000 + X) into the accumulator
809023  sta $2115                    [812115]; Store the accumulator value into the address $2115
809026  xba                                    ; Exchange the low and high bytes of the accumulator
809027  cmp #$39                               ; Compare the accumulator with the immediate value $39
809029  bcc $902f                              ; Branch to $902f if the Carry flag is clear
80902b  clc                                    ; Clear the Carry flag
80902c  lda $213a                    [81213a]; Load the value at address $213a into the accumulator
80902f  lda $7e0008,x               [7e0008]; Load the value at address ($7e0008 + X) into the accumulator
809033  sta $04                       [000004]; Store the accumulator value into the address $04
809035  sty $420b                    [81420b]; Store the Y register value into the address $420b
809038  rep #$20                              ; Reset processor status bits defined by $20 (e.g., enable 16-bit accumulator and index registers)
80903a  txa                                    ; Transfer the value in the X register to the accumulator
80903b  adc #$000b                             ; Add the immediate value $000b to the accumulator with carry
80903e  tax                                    ; Transfer the value in the accumulator to the X register
;;; Loop back
80903f  bra $8fff                    [808fff]; Branch to the relative address $8fff
809041  lda #$0000                             ; Load the immediate value $0000 into the accumulator
809044  tcd                                    ; Transfer the accumulator to the Direct Page Register (DPR)
809045  lda #$3600                             ; Load the immediate value $3600 into the accumulator
809048  sta $48                       [000048]; Store the accumulator value into the address $48
80904a  lda #$3a00                             ; Load the immediate value $3a00 into the accumulator
80904d  sta $4a                       [00004a]; Store the accumulator value into the address $4a
80904f  rtl                                    ; Return from subroutine (long return, restoring 24-bit address)




for loop += b

Flag M


